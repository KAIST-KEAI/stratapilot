{
    "view_cpu_usage": {
        "code": "import os\nfrom jarvis.action.base_action import BaseAction\nimport subprocess\n\nclass view_cpu_usage(BaseAction):\n    def __init__(self):\n        self._description = \"Open the terminal interface and view the system's CPU usage.\"\n\n    def __call__(self, working_directory=None, *args, **kwargs):\n        \"\"\"\n        Open the terminal interface and view the system's CPU usage.\n\n        Args:\n        working_directory (str): The working directory where the terminal will be opened.\n        \n        Returns:\n        None\n        \"\"\"\n        # Check if working_directory is provided, if not, use the current working directory\n        if working_directory:\n            # Change the current working directory to the provided working_directory\n            os.chdir(working_directory)\n        \n        # Open the terminal and call relevant instructions to view the system's CPU usage\n        subprocess.run([\"gnome-terminal\", \"--\", \"top\"])\n",
        "description": "Open the terminal interface and view the system's CPU usage."
    },
    "create_folder": {
        "code": "from jarvis.action.base_action import BaseAction\nimport os\n\nclass create_folder(BaseAction):\n    def __init__(self):\n        self._description = \"Create a folder under the default working directory.\"\n\n    def __call__(self, working_directory=None, folder_name='myfold', *args, **kwargs):\n        \"\"\"\n        Create a folder under the specified working directory or the default working directory.\n\n        Args:\n        working_directory (str): The path of the working directory. If not provided, the default working directory will be used.\n        folder_name (str): The name of the folder to be created. Default is 'myfold'.\n\n        Returns:\n        None\n        \"\"\"\n        # Check if the working_directory is provided, if not, use the default working directory\n        if working_directory:\n            os.chdir(working_directory)\n\n        # Create the folder\n        os.makedirs(folder_name)\n\n# Example of how to use the class\n# create_folder_action = create_folder()\n# create_folder_action(working_directory='/home/heroding/\u684c\u9762/Jarvis/working_dir', folder_name='my_new_folder')\n",
        "description": "Create a folder under the default working directory."
    },
    "install_package": {
        "code": "from jarvis.action.base_action import BaseAction\nimport subprocess\nimport sys\n\n\nclass install_package(BaseAction):\n    def __init__(self) -> None:\n        super().__init__()\n        self._description = \"install environment missing package.\"\n        self.action_type = 'BASH'\n\n    def __call__(self, package: str, *args, **kwargs):\n\n        \"\"\"\n        Install a Python package using pip.\n\n        Args:\n        package_name (str): Name of the package to install.\n        \"\"\"\n        try:\n            subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])\n            print(f\"Package '{package}' installed successfully.\")\n        except subprocess.CalledProcessError as e:\n            print(f\"Failed to install package '{package}'. Error: {e}\")\n        \n        # try:\n        #     # \u68c0\u67e5pip\u662f\u5426\u5df2\u5b89\u88c5\n        #     print(\"check pip ...\")\n        #     subprocess.check_call([sys.executable, '-m', 'pip', '--version'])\n        # except subprocess.CalledProcessError:\n        #     # \u5b89\u88c5pip\n        #     print(\"Installing pip...\")\n        #     subprocess.check_call([sys.executable, '-m', 'ensurepip'])\n\n        # # \u5b89\u88c5\u6307\u5b9a\u7684\u5305\n        # try:\n        #     print(f\"Installing {package}...\")\n        #     subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])\n        #     print(f\"{package} installed successfully.\")\n        # except subprocess.CalledProcessError:\n        #     print(f\"Failed to install {package}.\")        \n\n",
        "description": "install environment missing package."
    },
    "zip_files": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport os\nimport zipfile\nfrom pathlib import Path\n\nclass zip_files(BaseAction):\n    def __init__(self):\n        self._description = \"Zip all the files in a specified folder and name the zip file with a specified filename.\"\n\n    def __call__(self, folder_path, zip_name, working_directory=None):\n        \"\"\"\n        Create a zip archive of all files in the specified folder.\n\n        Args:\n            folder_path (str): The path to the folder whose files are to be zipped.\n            zip_name (str): The name of the resulting zip file.\n            working_directory (str, optional): The working directory where the folder is located. \n                If not provided, the current working directory is used.\n\n        Returns:\n            None: This method performs a task and does not return a value.\n        \"\"\"\n        # Use the provided working directory or the current working directory if not provided\n        working_directory = working_directory or os.getcwd()\n        \n        # Change the current working directory to the specified path\n        os.chdir(working_directory)\n        \n        # Ensure the folder path is a Path object for compatibility\n        folder_path = Path(folder_path)\n        \n        # Construct the full path for the zip file\n        zip_file_path = folder_path.parent / f\"{zip_name}.zip\"\n        \n        # Create a zip file and add all files from the specified folder\n        with zipfile.ZipFile(zip_file_path, 'w') as zipf:\n            for file in folder_path.glob('*'):\n                if file.is_file():\n                    zipf.write(file, arcname=file.name)\n        \n        print(f\"Task completed: '{zip_file_path}' has been created with all files from '{folder_path}'.\")\n\n# Example of how to use the class (this should be in comments):\n# To use this class, you would do something like the following:\n# zipper = zip_files()\n# zipper(folder_path='document', zip_name='agent', working_directory='/home/heroding/\u684c\u9762/Jarvis/working_dir')\n",
        "description": "Zip all the files in a specified folder and name the zip file with a specified filename."
    },
    "unzip_files": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport os\nimport zipfile\nimport subprocess\n\nclass unzip_files(BaseAction):\n    def __init__(self):\n        self._description = \"Unzip a specified .zip file into a designated folder.\"\n\n    def __call__(self, zip_file_path, destination_folder, working_directory=None, *args, **kwargs):\n        \"\"\"\n        Unzip the specified .zip file into the designated folder.\n\n        Args:\n            zip_file_path (str): The path to the .zip file to be unzipped.\n            destination_folder (str): The folder where the .zip file contents will be extracted.\n            working_directory (str, optional): The working directory where the operation will be performed.\n                If not provided, the current working directory will be used.\n\n        Returns:\n            None\n        \"\"\"\n        # If a working directory is provided, change to that directory\n        if working_directory:\n            os.chdir(working_directory)\n        else:\n            # Use the current working directory if none is provided\n            working_directory = os.getcwd()\n\n        # Ensure the destination folder exists\n        destination_path = os.path.join(working_directory, destination_folder)\n        os.makedirs(destination_path, exist_ok=True)\n\n        # Unzip the file\n        try:\n            with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:\n                zip_ref.extractall(destination_path)\n            print(f\"Unzipped {zip_file_path} into {destination_folder} successfully.\")\n        except zipfile.BadZipFile:\n            print(f\"Failed to unzip {zip_file_path}: The file may be corrupted or not a zip file.\")\n        except FileNotFoundError:\n            print(f\"Failed to unzip {zip_file_path}: The file does not exist.\")\n\n# Example of how to use the class (this should be in the comments and not executed):\n# unzipper = unzip_files()\n# unzipper(zip_file_path='agent.zip', destination_folder='myfold', working_directory='/home/heroding/\u684c\u9762/Jarvis/working_dir')\n",
        "description": "Unzip a specified .zip file into a designated folder."
    },
    "search_word": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport os\n\nclass search_word(BaseAction):\n    def __init__(self):\n        self._description = \"Search each text file for a specified word and return the paths of files that contain the word.\"\n\n    def __call__(self, file_paths, search_term, *args, **kwargs):\n        \"\"\"\n        Search each text file in the provided list for the specified word and return the paths of files that contain the word.\n\n        Args:\n            file_paths (list): List of absolute paths to text files to be searched.\n            search_term (str): The word to search for within the text files.\n\n        Returns:\n            list: The paths of files that contain the search term.\n        \"\"\"\n        matching_files = []\n        for file_path in file_paths:\n            try:\n                with open(file_path, 'r', encoding='utf-8') as file:\n                    if search_term in file.read():\n                        matching_files.append(file_path)\n            except FileNotFoundError:\n                print(f\"The file {file_path} does not exist.\")\n            except Exception as e:\n                print(f\"An error occurred while searching the file {file_path}: {e}\")\n\n        print(f\"Task execution complete. Found {len(matching_files)} files containing the word '{search_term}'.\")\n        return matching_files\n\n# Example of how to use the class (this should be in the comments):\n# searcher = search_word()\n# result = searcher(file_paths=['/path/to/file1.txt', '/path/to/file2.txt'], search_term='agent')\n",
        "description": "Search each text file for a specified word and return the paths of files that contain the word."
    },
    "read_layout_file": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport os\n\nclass read_layout_file(BaseAction):\n    def __init__(self):\n        self._description = \"Read the content of a specified text file.\"\n\n    def __call__(self, file_path, *args, **kwargs):\n        \"\"\"\n        Read the content of the specified text file and return its content.\n\n        Args:\n            file_path (str): The absolute path to the text file to be read.\n\n        Returns:\n            str: The content of the text file.\n        \"\"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as file:\n                content = file.read()\n            print(f\"Task execution complete. Content of the file {file_path} read successfully.\")\n            return content\n        except FileNotFoundError:\n            print(f\"The file {file_path} does not exist.\")\n        except Exception as e:\n            print(f\"An error occurred while reading the file {file_path}: {e}\")\n\n# Example of how to use the class (this should be in the comments):\n# reader = read_layout_file()\n# content = reader(file_path='/home/heroding/.cache/huggingface/datasets/downloads/70a1ee0ae9b188db8f50a933dc95ce2e1cd3cbe2d015c7b4bd91444f003db5fd.txt')\n",
        "description": "Read the content of a specified text file."
    },
    "extract_excel_content": {
        "code": "from jarvis.action.base_action import BaseAction\nimport pandas as pd\nimport os\n\nclass extract_excel_content(BaseAction):\n    def __init__(self):\n        self._description = \"Extract the full text content of the specified Excel file.\"\n\n    def __call__(self, excel_file_path, *args, **kwargs):\n        \"\"\"\n        Extract the full text content of the specified Excel file and return its content.\n\n        Args:\n            excel_file_path (str): The absolute path to the Excel file to be read.\n\n        Returns:\n            dict: A dictionary where each key is the sheet name and each value is the content of that sheet as a DataFrame.\n        \"\"\"\n        try:\n            # Read the Excel file\n            with pd.ExcelFile(excel_file_path) as xls:\n                # Dictionary to store content of each sheet\n                sheets_content = {}\n                max_rows = 0\n                max_columns = 0\n                for sheet_name in xls.sheet_names:\n                    # Read each sheet into a DataFrame\n                    df = pd.read_excel(xls, sheet_name)\n                    sheets_content[sheet_name] = df\n                    max_rows = max(max_rows, df.shape[0])\n                    max_columns = max(max_columns, df.shape[1])\n            pd.set_option('display.max_rows', max_rows)\n            pd.set_option('display.max_columns', max_columns)\n            print(f\"Task execution complete. Content of the Excel file {excel_file_path} extracted successfully.\")\n            return sheets_content\n        except FileNotFoundError:\n            print(f\"The Excel file {excel_file_path} does not exist.\")\n        except Exception as e:\n            print(f\"An error occurred while reading the Excel file {excel_file_path}: {e}\")\n\n# Example of how to use the class (this should be in the comments):\n# extractor = extract_excel_content()\n# content = extractor(excel_file_path='/home/heroding/.cache/huggingface/datasets/downloads/9fbb70f8ea7240bdd24693c968fa879fd2e186fdedf2d1e709c59e096c865b25.xlsx')\n",
        "description": "Extract the full text content of the specified Excel file."
    },
    "extract_pdf_content": {
        "code": "from jarvis.action.base_action import BaseAction\nimport PyPDF2\nimport os\n\nclass extract_pdf_content(BaseAction):\n    def __init__(self):\n        self._description = \"Extract the text content from a specified PDF file.\"\n\n    def __call__(self, pdf_file_path, *args, **kwargs):\n        \"\"\"\n        Extract the text content from the specified PDF file and return its content.\n\n        Args:\n            pdf_file_path (str): The absolute path to the PDF file to be read.\n\n        Returns:\n            str: The text content of the PDF file.\n        \"\"\"\n        try:\n            # Ensure the PDF file exists\n            if not os.path.isfile(pdf_file_path):\n                print(f\"The PDF file {pdf_file_path} does not exist.\")\n                return\n            \n            # Open the PDF file\n            with open(pdf_file_path, 'rb') as file:\n                pdf_reader = PyPDF2.PdfReader(file)\n                text_content = ''\n                \n                # Iterate through each page and extract text\n                for page_num in range(len(pdf_reader.pages)):\n                    page = pdf_reader.pages[page_num]\n                    text_content += page.extract_text()\n            \n            print(f\"Task execution complete. Content of the PDF file {pdf_file_path} extracted successfully.\")\n            return text_content\n        except FileNotFoundError:\n            print(f\"The PDF file {pdf_file_path} does not exist.\")\n        except PyPDF2.errors.PdfReadError as e:\n            print(f\"An error occurred while reading the PDF file {pdf_file_path}: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n\n\n# Example of how to use the class (this should be in the comments):\n# extractor = extract_pdf_content()\n# content = extractor(pdf_file_path='/home/heroding/.cache/huggingface/datasets/downloads/9f3ace58caffc356d97dd86ada4e266d2054f59dad0950f287f9791ddcff64fa.pdf')\n",
        "description": "Extract the text content from a specified PDF file."
    },
    "extract_jsonl_content": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport json\nimport os\n\nclass extract_jsonl_content(BaseAction):\n    def __init__(self):\n        self._description = \"Extract the full text content of the specified JSON Lines file.\"\n\n    def __call__(self, jsonl_file_path, *args, **kwargs):\n        \"\"\"\n        Extract the full text content of the specified JSON Lines file and return its content.\n\n        Args:\n            jsonl_file_path (str): The absolute path to the JSON Lines file to be read.\n\n        Returns:\n            list: A list of dictionaries, each representing a line in the JSON Lines file.\n        \"\"\"\n        try:\n            # Change the current working directory to the specified path if provided\n            working_dir = kwargs.get('working_dir', os.getcwd())\n            os.chdir(working_dir)\n\n            # Ensure the JSON Lines file exists\n            if not os.path.isfile(jsonl_file_path):\n                print(f\"The JSON Lines file {jsonl_file_path} does not exist.\")\n                return\n\n            # Read the JSON Lines file\n            content = []\n            with open(jsonl_file_path, 'r', encoding='utf-8') as file:\n                for line in file:\n                    content.append(json.loads(line.strip()))\n\n            print(f\"Task execution complete. Content of the JSON Lines file {jsonl_file_path} extracted successfully.\")\n            return content\n        except FileNotFoundError:\n            print(f\"The JSON Lines file {jsonl_file_path} does not exist.\")\n        except json.JSONDecodeError as e:\n            print(f\"An error occurred while parsing the JSON Lines file {jsonl_file_path}: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n\n# Example of how to use the class (this should be in the comments):\n# extractor = extract_jsonl_content()\n# content = extractor(jsonl_file_path='/home/heroding/\u684c\u9762/Jarvis/working_dir/2023_validation_metadata.jsonl')\n",
        "description": "Extract the full text content of the specified JSON Lines file."
    },
    "read_csv_file": {
        "code": "from jarvis.action.base_action import BaseAction\nimport pandas as pd\nimport os\n\nclass read_csv_file(BaseAction):\n    def __init__(self):\n        self._description = \"Read the content of a CSV file to extract data.\"\n\n    def __call__(self, csv_file_path, *args, **kwargs):\n        \"\"\"\n        Read the content of the specified CSV file and return its content as a DataFrame.\n\n        Args:\n            csv_file_path (str): The absolute path to the CSV file to be read.\n\n        Returns:\n            DataFrame: The content of the CSV file as a pandas DataFrame.\n        \"\"\"\n        try:\n            # Change the current working directory to the directory of the CSV file\n            dir_path = os.path.dirname(csv_file_path)\n            os.chdir(dir_path)\n            \n            # Set the display options of Pandas to show all rows and columns\n            pd.set_option('display.max_rows', None)\n            pd.set_option('display.max_columns', None)\n\n            # Read the CSV file\n            data = pd.read_csv(os.path.basename(csv_file_path))\n            print(f\"Task execution complete. Content of the CSV file {csv_file_path} read successfully.\")\n            return data\n        except FileNotFoundError:\n            print(f\"The CSV file {csv_file_path} does not exist.\")\n        except Exception as e:\n            print(f\"An error occurred while reading the CSV file {csv_file_path}: {e}\")\n\n\n# Example of how to use the class (this should be in the comments):\n# reader = read_csv_file()\n# penguin_data = reader(csv_file_path='/home/heroding/.cache/huggingface/datasets/downloads/f78694ef938cb07a34ab1ca2ccf515e1433c479ca40632f122d332288dda688b.csv')",
        "description": "Read the content of a CSV file to extract data."
    },
    "calculate_audio_duration": {
        "code": "from jarvis.action.base_action import BaseAction\nfrom pydub import AudioSegment\nimport os\n\nclass calculate_audio_duration(BaseAction):\n    def __init__(self):\n        self._description = \"Calculate the duration of the specified audio file and return the duration in seconds.\"\n\n    def __call__(self, audio_file_path, *args, **kwargs):\n        \"\"\"\n        Calculate the duration of the specified audio file and return the duration in seconds.\n\n        Args:\n            audio_file_path (str): The absolute path to the audio file.\n\n        Returns:\n            float: The duration of the audio file in seconds.\n        \"\"\"\n        try:\n            # Ensure the audio file exists\n            if not os.path.isfile(audio_file_path):\n                print(f\"The audio file {audio_file_path} does not exist.\")\n                return\n            \n            # Load the audio file\n            audio = AudioSegment.from_file(audio_file_path)\n            \n            # Calculate the duration in milliseconds and convert to seconds\n            duration_seconds = len(audio) / 1000.0\n            \n            print(f\"Task execution complete. Duration of the audio file {audio_file_path} is {duration_seconds} seconds.\")\n            return duration_seconds\n        except FileNotFoundError:\n            print(f\"The audio file {audio_file_path} does not exist.\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n\n# Example of how to use the class (this should be in the comments):\n# duration_calculator = calculate_audio_duration()\n# duration = duration_calculator(audio_file_path='/path/to/audio/file.mp3')",
        "description": "Calculate the duration of the specified audio file and return the duration in seconds."
    },
    "implement_newtons_method": {
        "code": "from jarvis.action.base_action import BaseAction\nfrom sympy import symbols, diff, Rational\n\nclass implement_newtons_method(BaseAction):\n    def __init__(self):\n        self._description = \"Implement Newton's Method to find a root of the function f(x).\"\n\n    def __call__(self, f_expression, x0, denominator_digits, max_iter=100, *args, **kwargs):\n        \"\"\"\n        Approximate the roots of the function using Newton's Method starting from x_0.\n        Iterate until the denominator of the fraction, when fully reduced, has a specified number of digits.\n\n        Args:\n            f_expression (string): The function expression for which the root is to be found.\n            x0 (float or sympy expression): The initial guess for the root.\n            denominator_digits (int): The number of digits in the denominator to check for.\n            max_iter (int, optional): Maximum number of iterations. Defaults to 100.\n\n        Returns:\n        tuple: A tuple containing the smallest n where the denominator of the approximation has 25 digits and the corresponding approximation.\n               Returns (None, None) if no such n is found within max_iter.\n            \"\"\"\n        # Create a symbol x dynamically\n        x = symbols('x')\n\n        # Convert the string expression to a sympy expression\n        f = eval(f_expression)\n\n        # First derivative of the function\n        f_prime = diff(f, x)\n\n        for n in range(max_iter):\n            # Calculate the next approximation\n            x1 = x0 - f.subs(x, x0)/f_prime.subs(x, x0)\n\n            # Check if the denominator has the specified number of digits when the fraction is fully reduced\n            if len(str(Rational(x1).q)) >= denominator_digits:\n                return n + 1, x1  # n + 1 because we start counting from 1\n\n            x0 = x1\n\n        return None, None\n\n# Example of how to use the class (this should be in the comments):\n# newtons_method = implement_newtons_method()\n# n, approximation = newtons_method(f_expression=\"x**3 - 5*x**2 + 2*x\", x0=1, denominator_digits=25, max_iter=100)",
        "description": "Implement Newton's Method to find a root of the function f(x)."
    },
    "read_json_file": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport json\nimport os\n\nclass read_json_file(BaseAction):\n    def __init__(self):\n        self._description = \"Read the content of the specified JSON file.\"\n\n    def __call__(self, json_file_path, *args, **kwargs):\n        \"\"\"\n        Read the content of the specified JSON file and return its content.\n\n        Args:\n            json_file_path (str): The absolute path to the JSON file to be read.\n\n        Returns:\n            dict: The content of the JSON file.\n        \"\"\"\n        try:\n            # Ensure the JSON file exists\n            if not os.path.isfile(json_file_path):\n                print(f\"The JSON file {json_file_path} does not exist.\")\n                return\n\n            # Read the JSON file\n            with open(json_file_path, 'r', encoding='utf-8') as file:\n                content = json.load(file)\n\n            print(f\"Task execution complete. Content of the JSON file {json_file_path} read successfully.\")\n            return content\n        except FileNotFoundError:\n            print(f\"The JSON file {json_file_path} does not exist.\")\n        except json.JSONDecodeError as e:\n            print(f\"An error occurred while parsing the JSON file {json_file_path}: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n\n# Example of how to use the class (this should be in the comments):\n# reader = read_json_file()\n# content = reader(json_file_path='/home/heroding/.cache/huggingface/datasets/downloads/bb3eef7d0e0a0283bff6e45060ed0fc57055c2e324d7efc7dc322d5055d1e2da.json')\n",
        "description": "Read the content of the specified JSON file."
    },
    "calculate_adjacent_distances": {
        "code": "from jarvis.action.base_action import BaseAction\nimport pandas as pd\nimport os\nfrom geopy.distance import geodesic\n\nclass calculate_adjacent_distances(BaseAction):\n    def __init__(self):\n        self._description = \"Calculate the distances between each pair of adjacent site using latitude and longitude.\"\n\n    def __call__(self, stations, *args, **kwargs):\n        \"\"\"\n        Calculate the distances between each pair of adjacent stations using the geopy library.\n\n        Args:\n            stations - A list of tuples, where each tuple contains the name of the station and its coordinates.\n                       The format of each tuple is (station_name, (latitude, longitude)).\n\n        \n        Returns:\n            A list of strings, each describing the distance between a pair of adjacent stations.\n            Each string is formatted as \"Distance between [Station1] and [Station2]: [distance] km\".\n\n        \"\"\"\n        distances = []\n        for i in range(len(stations) - 1):\n            name1, coords1 = stations[i]\n            name2, coords2 = stations[i + 1]\n            distance = geodesic(coords1, coords2).kilometers  # Calculating distance using geodesic method\n            distances.append(f\"Distance between {name1} and {name2}: {distance:.2f} km\")\n        return distances\n\n# Example of how to use the class (this should be in the comments):\n# calculator = calculate_distances()\n# stations = [\n#     ('Alpha', (40.757707, -73.997332)),\n#     ('Beta', (40.817108, -73.958537)),\n#     # ... add other stations here\n# ]\n# distances = calculator(stations)",
        "description": "Calculate the distances between each pair of adjacent site using latitude and longitude."
    },
    "execute_original_python_code": {
        "code": "from jarvis.action.base_action import BaseAction\nimport subprocess\nimport os\nimport sys\nimport tempfile\n\nclass execute_original_python_code(BaseAction):\n    def __init__(self):\n        self._description = \"Execute the Python code read from a file and get the original output.\"\n\n    def __call__(self, python_code, working_dir=None, *args, **kwargs):\n        \"\"\"\n        Execute the provided Python code and print the output.\n\n        Args:\n            python_code (str): The Python code to be executed.\n            working_dir (str, optional): The working directory where the code should be executed. Defaults to the current working directory.\n\n        Returns:\n            The result of the Code execution.\n        \"\"\"\n        # Set the working directory if provided, otherwise use the current working directory\n        if working_dir:\n            os.chdir(working_dir)\n        else:\n            working_dir = os.getcwd()\n\n        # Create a temporary file to store the Python code\n        with tempfile.NamedTemporaryFile(mode='w+', suffix='.py', dir=working_dir, delete=False) as temp_file:\n            temp_file_name = temp_file.name\n            temp_file.write(python_code)\n            temp_file.flush()\n\n            # Execute the Python code using the Python interpreter\n            try:\n                result = subprocess.run([sys.executable, temp_file_name], capture_output=True, text=True, check=True)\n                return result.stdout.strip()\n            except subprocess.CalledProcessError as e:\n                print(f\"An error occurred while executing the Python code: {e.stderr}\", file=sys.stderr)\n            finally:\n                # Remove the temporary file\n                os.unlink(temp_file_name)\n\n# Example of how to use the class (this should be in the comments):\n# executor = execute_original_python_code()\n# executor(python_code=read_python_code_return_val[0], working_dir='/home/heroding/\u684c\u9762/Jarvis/working_dir')",
        "description": "Execute the Python code read from a file and get the original output."
    },
    "read_text_file": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport os\n\nclass read_text_file(BaseAction):\n    def __init__(self):\n        self._description = \"Read the full text content of a specified text file.\"\n\n    def __call__(self, file_path, *args, **kwargs):\n        \"\"\"\n        Read the content of the specified text file and return its content.\n\n        Args:\n            file_path (str): The absolute path to the text file to be read.\n\n        Returns:\n            str: The content of the text file, or None if an error occurs.\n        \"\"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as file:\n                content = file.read()\n            print(f\"Task execution complete. Content of the file {file_path} read successfully.\")\n            return content\n        except FileNotFoundError:\n            print(f\"The file {file_path} does not exist.\")\n            return None\n        except Exception as e:\n            print(f\"An error occurred while reading the file {file_path}: {e}\")\n            return None\n\n# Example of how to use the class (this should be in the comments):\n# reader = read_text_file()\n# content = reader(file_path='/home/heroding/.cache/huggingface/datasets/downloads/90d142b33359cd5fba1aa1ac9be83cd48d112baf51a675fc08e26d5b1d5c0402.txt')\n",
        "description": "Read the full text content of a specified text file."
    },
    "read_xml_file": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport os\nimport xml.etree.ElementTree as ET\n\nclass read_xml_file(BaseAction):\n    def __init__(self):\n        self._description = \"Read the full text content of the specified XML file.\"\n\n    def __call__(self, file_path, *args, **kwargs):\n        \"\"\"\n        Read the content of the specified XML file and return its content.\n\n        Args:\n            file_path (str): The absolute path to the XML file to be read.\n\n        Returns:\n            str: The content of the XML file, or None if an error occurs.\n        \"\"\"\n        try:\n            # Change the current working directory to the directory of the file\n            os.chdir(os.path.dirname(file_path))\n            \n            # Parse the XML file\n            tree = ET.parse(os.path.basename(file_path))\n            root = tree.getroot()\n            \n            # Convert the XML tree to a string\n            content = ET.tostring(root, encoding='unicode')\n            \n            print(f\"Task execution complete. Content of the XML file {file_path} read successfully.\")\n            return content\n        except FileNotFoundError:\n            print(f\"The XML file {file_path} does not exist.\")\n            return None\n        except ET.ParseError as e:\n            print(f\"An error occurred while parsing the XML file {file_path}: {e}\")\n            return None\n        except Exception as e:\n            print(f\"An error occurred while reading the XML file {file_path}: {e}\")\n            return None\n\n# Example of how to use the class (this should be in the comments):\n# reader = read_xml_file()\n# content = reader(file_path='/home/heroding/.cache/huggingface/datasets/downloads/4b570797236b2208d14d90be2da93e5c6ce24b1e73d43d9632136e43effa2ad1.xml')\n",
        "description": "Read the full text content of the specified XML file."
    },
    "calculate_ISBN10_digits": {
        "code": "from jarvis.action.base_action import BaseAction\n\nclass calculate_ISBN10_digits(BaseAction):\n    def __init__(self):\n        self._description = \"Calculate the ISBN-10 check digits for the provided 9-digit numbers.\"\n\n    def __call__(self, numbers, *args, **kwargs):\n        \"\"\"\n        Calculate the ISBN-10 check digits for the provided 9-digit numbers and replace any 'X' with '0'.\n\n        Args:\n            numbers (list of str): The list of 9-digit numbers as strings for which the check digits are to be calculated.\n\n        Returns:\n            list of str: The list of calculated check digits for the provided numbers.\n        \"\"\"\n        check_digits = []\n        for number in numbers:\n            try:\n                # Replace 'X' with '0' and calculate the check digit\n                number = number.replace('X', '0')\n                total = sum((i + 1) * int(digit) for i, digit in enumerate(number))\n                check_digit = total % 11\n                check_digit = 'X' if check_digit == 10 else str(check_digit)\n                check_digits.append(check_digit)\n                print(f\"Check digit for ISBN-10 number {number} is {check_digit}.\")\n            except ValueError as e:\n                print(f\"Invalid number {number}: {e}\")\n            except Exception as e:\n                print(f\"An error occurred while calculating the check digit for {number}: {e}\")\n        return check_digits\n\n# Example of how to use the class (this should be in the comments):\n# check_digit_calculator = calculate_ISBN10_digits()\n# check_digits = check_digit_calculator(numbers=[\"478225952\", \"643485613\", \"739394228\", \"291726859\", \"875262394\", \"542617795\", \"031810713\", \"957007669\", \"871467426\"])",
        "description": "Calculate the ISBN-10 check digits for the provided 9-digit numbers."
    },
    "sort_by_indices": {
        "code": "from jarvis.action.base_action import BaseAction\n\nclass sort_by_indices(BaseAction):\n    def __init__(self):\n        self._description = \"Sorts an array based on the order defined in a separate list of indices.\"\n\n    def __call__(self, arr, indices, *args, **kwargs):\n        \"\"\"\n        Sorts an array based on the order defined in a separate list of indices.\n\n        Args:\n        arr (list): The list of strings to be sorted.\n        indices (list): A list of integers representing the desired order of elements in 'arr'.\n                    Each integer in 'indices' is an index in 'arr' that specifies the order.\n        \n        Returns:\n        list: A new list of strings from 'arr' arranged according to the order specified in 'indices'.\n        \"\"\"\n        # Create the new number based on the specified order\n        new_number = ''.join(arr[i - 1] for i in indices)\n        \n        # Print the task execution completion message\n        print(f\"New 9-digit number created: {new_number}\")\n        \n        return new_number\n\nsort = sort_by_indices()\nordered_list = sort([\"2\", \"0\", \"3\", \"0\", \"7\", \"3\", \"9\", \"0\", \"2\"], [5, 8, 7, 3, 6, 4, 9, 2, 1])",
        "description": "Sorts an array based on the order defined in a separate list of indices."
    },
    "plot_lines_general": {
        "code": "from jarvis.action.base_action import BaseAction\nimport matplotlib.pyplot as plt\n\nclass plot_lines_general(BaseAction):\n    def __init__(self):\n        self._description = \"Plots lines connecting numbers and letters based on the given connections and optionally saves the plot as an image.\"\n\n    def __call__(self, connections, numbers, letters, path):\n        \"\"\"\n        Plots lines connecting numbers and letters based on the given connections and optionally saves the plot as an image.\n\n        Parameters:\n        connections (dict): A dictionary where keys are numbers and values are letters, representing the connections. The format of the dictionary key is a number, and the format of the value is a string.\n        numbers (list): A list of numbers to be plotted.\n        letters (list): A list of letters to be plotted. The order of letters should correspond to the order of numbers.\n        path (string): Save the plot as an image with the path.\n\n        Output:\n        A matplotlib plot showing the connections between the numbers and letters.\n        \"\"\"\n\n        # Determine positions for letters\n        # letter_positions = {letter: i + 1 for i, letter in enumerate(letters)}\n\n        # plt.figure(figsize=(10, 6))\n\n        # # Plotting the numbers and letters on the x-axis\n        # plt.plot(numbers, [1] * len(numbers), 'o', color='blue')  # Numbers\n        # plt.plot(numbers, [0] * len(letters), 'o', color='red')  # Letters\n\n        # # Drawing lines between the numbers and letters\n        # for num, letter in connections.items():\n        #     if letter in letter_positions:\n        #         plt.plot([num, letter_positions[letter]], [1, 0], color='green')\n\n        # plt.title(\"Line Connections\")\n        # plt.yticks([0, 1], ['Letters', 'Numbers'])\n        # plt.xticks(range(1, len(numbers) + 1))\n        # plt.grid(True)\n        # if path:\n        #     plt.savefig(path)\n        # plt.show()\n\n        # Determine positions for letters\n        letter_positions = {letter: i + 1 for i, letter in enumerate(letters)}\n\n        # Create a figure for plotting\n        plt.figure(figsize=(10, 6))\n\n        # Plotting the numbers and letters on the x-axis\n        plt.plot(numbers, [1] * len(numbers), 'o', color='blue')  # Numbers\n        plt.plot(numbers, [0] * len(letters), 'o', color='red')  # Letters\n\n        # Drawing lines between the numbers and letters\n        for num, letter in connections.items():\n            if letter in letter_positions:\n                plt.plot([num, letter_positions[letter]], [1, 0], color='green')\n\n        # Set the title and labels for the plot\n        plt.title(\"Line Connections\")\n        plt.yticks([0, 1], ['Letters', 'Numbers'])\n        plt.xticks(range(1, len(numbers) + 1))\n        plt.grid(True)\n\n        # Save the plot as an image\n        plt.savefig(path)\n        plt.close()\n\n# Example of how to use the class\nplot_lines = plot_lines_general()\nplot = plot_lines({1:\"e\",5:\"a\",2:\"b\",4:\"d\"}, [1, 2, 3, 4, 5], ['a', 'b', 'c', 'd', 'e'], \"/home/heroding/\u684c\u9762/Jarvis/working_dir/plot.png\")\n\n\n",
        "description": "Plots lines connecting numbers and letters based on the given connections and optionally saves the plot as an image."
    },
    "plot_line_graph": {
        "code": "from jarvis.action.base_action import BaseAction\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport os\n\nclass plot_line_graph(BaseAction):\n    def __init__(self):\n        self._description = \"Use matplotlib to plot the data into a line graph.\"\n\n    def __call__(self, data, output_path=None, working_directory=None, *args, **kwargs):\n        \"\"\"\n        Plots the data into a line graph using matplotlib and optionally saves the plot as an image.\n\n        Args:\n            data (dict): A dictionary containing the data to be plotted. The keys are the x-axis labels and the values are the y-axis values.\n            output_path (str, optional): The path where the plot image will be saved. If not provided, the plot will not be saved.\n            working_directory (str, optional): The working directory where the file operations should be performed. If not provided, the current working directory will be used.\n\n        Returns:\n            None\n        \"\"\"\n        # Change the current working directory to the provided working_directory if provided\n        if working_directory:\n            os.chdir(working_directory)\n\n        # Extract x and y values from the data\n        x_values = list(data.keys())\n        y_values = list(data.values())\n\n        # Create a figure and axis for the plot\n        fig, ax = plt.subplots()\n\n        # Plot the data\n        ax.plot(x_values, y_values)\n\n        # Set the labels and title\n        ax.set_xlabel('X-axis')\n        ax.set_ylabel('Y-axis')\n        ax.set_title('Line Graph')\n\n        # Optionally save the plot to the output_path\n        if output_path:\n            plt.savefig(output_path)\n\n        # Show the plot\n        plt.show()\n\n        # Print completion message\n        print(\"Plotting completed.\")\n\n# Example of how to use the class (this should be in the comments):\n# plotter = plot_line_graph()\n# data = {'1': 1, '2': 2, '3': 3, '4': 4, '5': 5}\n# plotter(data, \"/home/heroding/\u684c\u9762/Jarvis/working_dir/line.png\", \"/home/heroding/\u684c\u9762/Jarvis/working_dir\")",
        "description": "Use matplotlib to plot the data into a line graph."
    },
    "plot_two_lines_graph": {
        "code": "from jarvis.action.base_action import BaseAction\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport os\n\nclass plot_two_lines_graph(BaseAction):\n    def __init__(self):\n        self._description = \"Use matplotlib to plot the data into a line graph with 'x' as the horizontal axis and 'y1' and 'y2' as the vertical axes, then save the graph as 'lines.png' in the working directory.\"\n\n    def __call__(self, data, output_filename='lines.png', working_directory=None, *args, **kwargs):\n        \"\"\"\n        Plots the data into a line graph using matplotlib and saves the graph as an image in the working directory.\n\n        Args:\n            data (dict): A dictionary containing the data to be plotted with 'x' as keys and 'y1', 'y2' as values.\n            output_filename (str, optional): The filename for the saved plot image. Defaults to 'lines.png'.\n            working_directory (str, optional): The working directory where the file operations should be performed. If not provided, the current working directory will be used.\n\n        Returns:\n            None\n        \"\"\"\n        # Change the current working directory to the provided working_directory if provided\n        if working_directory:\n            os.chdir(working_directory)\n\n        # Extract x and y values from the data\n        x_values = data['x']\n        y1_values = data['y1']\n        y2_values = data['y2']\n\n        # Create a figure and axis for the plot\n        fig, ax = plt.subplots()\n\n        # Plot the data\n        ax.plot(x_values, y1_values, label='y1')\n        ax.plot(x_values, y2_values, label='y2')\n\n        # Set the labels and title\n        ax.set_xlabel('x')\n        ax.set_ylabel('y')\n        ax.set_title('Line Graph')\n\n        # Add a legend\n        ax.legend()\n\n        # Save the plot to the output_filename\n        plt.savefig(output_filename)\n\n        # Print completion message\n        print(f\"Plotting completed. Graph saved as {output_filename}.\")\n\n# Example of how to use the class (this should be in the comments):\nplotter = plot_two_lines_graph()\ndata = {'x': [1, 2, 3, 4, 5], 'y1': [1, 2, 3, 4, 5], 'y2': [2, 4, 6, 8, 10]}\nplotter(data, \"lines.png\", \"/home/heroding/\u684c\u9762/Jarvis/working_dir\")",
        "description": "Use matplotlib to plot the data into a line graph with 'x' as the horizontal axis and 'y1' and 'y2' as the vertical axes, then save the graph as 'lines.png' in the working directory."
    }
}