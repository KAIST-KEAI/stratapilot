{
    "view_cpu_usage": {
        "code": "import os\nfrom jarvis.action.base_action import BaseAction\nimport subprocess\n\nclass view_cpu_usage(BaseAction):\n    def __init__(self):\n        self._description = \"Open the terminal interface and view the system's CPU usage.\"\n\n    def __call__(self, working_directory=None, *args, **kwargs):\n        \"\"\"\n        Open the terminal interface and view the system's CPU usage.\n\n        Args:\n        working_directory (str): The working directory where the terminal will be opened.\n        \n        Returns:\n        None\n        \"\"\"\n        # Check if working_directory is provided, if not, use the current working directory\n        if working_directory:\n            # Change the current working directory to the provided working_directory\n            os.chdir(working_directory)\n        \n        # Open the terminal and call relevant instructions to view the system's CPU usage\n        subprocess.run([\"gnome-terminal\", \"--\", \"top\"])\n",
        "description": "Open the terminal interface and view the system's CPU usage."
    },
    "create_folder": {
        "code": "from jarvis.action.base_action import BaseAction\nimport os\n\nclass create_folder(BaseAction):\n    def __init__(self):\n        self._description = \"Create a folder under the default working directory.\"\n\n    def __call__(self, working_directory=None, folder_name='myfold', *args, **kwargs):\n        \"\"\"\n        Create a folder under the specified working directory or the default working directory.\n\n        Args:\n        working_directory (str): The path of the working directory. If not provided, the default working directory will be used.\n        folder_name (str): The name of the folder to be created. Default is 'myfold'.\n\n        Returns:\n        None\n        \"\"\"\n        # Check if the working_directory is provided, if not, use the default working directory\n        if working_directory:\n            os.chdir(working_directory)\n\n        # Create the folder\n        os.makedirs(folder_name)\n\n# Example of how to use the class\n# create_folder_action = create_folder()\n# create_folder_action(working_directory='/home/heroding/\u684c\u9762/Jarvis/working_dir', folder_name='my_new_folder')\n",
        "description": "Create a folder under the default working directory."
    },
    "open_text_file": {
        "code": "from jarvis.action.base_action import BaseAction\nimport subprocess\nimport os\n\nclass open_text_file(BaseAction):\n    def __init__(self):\n        self._description = \"Open the specified text file in the specified folder using the default text viewer on Ubuntu.\"\n\n    def __call__(self, folder_name, file_name, working_directory=None):\n        \"\"\"\n        Open the specified text file in the specified folder using the default text viewer on Ubuntu.\n\n        Args:\n        folder_name (str): The name of the folder containing the text file.\n        file_name (str): The name of the text file to be opened.\n        working_directory (str, optional): The working directory where the folder is located. If not provided, the current working directory will be used.\n\n        Returns:\n        None\n        \"\"\"\n        # If the working directory is provided, use it. Otherwise, use the current working directory.\n        if working_directory:\n            os.chdir(working_directory)\n\n        # Construct the file path\n        file_path = os.path.join(folder_name, file_name)\n\n        # Open the text file using the default text viewer on Ubuntu\n        subprocess.run(['xdg-open', file_path])\n\n# Example of how to use the class:\n# open_file_task = open_text_file()\n# open_file_task(folder_name='myfold', file_name='result.txt', working_directory='/home/heroding/\u684c\u9762/Jarvis/working_dir')\n",
        "description": "Open the specified text file in the specified folder using the default text viewer on Ubuntu."
    },
    "install_package": {
        "code": "from jarvis.action.base_action import BaseAction\nimport subprocess\nimport sys\n\n\nclass install_package(BaseAction):\n    def __init__(self) -> None:\n        super().__init__()\n        self._description = \"install environment missing package.\"\n        self.action_type = 'BASH'\n\n    def __call__(self, package: str, *args, **kwargs):\n\n        \"\"\"\n        Install a Python package using pip.\n\n        Args:\n        package_name (str): Name of the package to install.\n        \"\"\"\n        try:\n            subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])\n            print(f\"Package '{package}' installed successfully.\")\n        except subprocess.CalledProcessError as e:\n            print(f\"Failed to install package '{package}'. Error: {e}\")\n        \n        # try:\n        #     # \u68c0\u67e5pip\u662f\u5426\u5df2\u5b89\u88c5\n        #     print(\"check pip ...\")\n        #     subprocess.check_call([sys.executable, '-m', 'pip', '--version'])\n        # except subprocess.CalledProcessError:\n        #     # \u5b89\u88c5pip\n        #     print(\"Installing pip...\")\n        #     subprocess.check_call([sys.executable, '-m', 'ensurepip'])\n\n        # # \u5b89\u88c5\u6307\u5b9a\u7684\u5305\n        # try:\n        #     print(f\"Installing {package}...\")\n        #     subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])\n        #     print(f\"{package} installed successfully.\")\n        # except subprocess.CalledProcessError:\n        #     print(f\"Failed to install {package}.\")        \n\n",
        "description": "install environment missing package."
    },
    "zip_files": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport os\nimport zipfile\nfrom pathlib import Path\n\nclass zip_files(BaseAction):\n    def __init__(self):\n        self._description = \"Zip all the files in a specified folder and name the zip file with a specified filename.\"\n\n    def __call__(self, folder_path, zip_name, working_directory=None):\n        \"\"\"\n        Create a zip archive of all files in the specified folder.\n\n        Args:\n            folder_path (str): The path to the folder whose files are to be zipped.\n            zip_name (str): The name of the resulting zip file.\n            working_directory (str, optional): The working directory where the folder is located. \n                If not provided, the current working directory is used.\n\n        Returns:\n            None: This method performs a task and does not return a value.\n        \"\"\"\n        # Use the provided working directory or the current working directory if not provided\n        working_directory = working_directory or os.getcwd()\n        \n        # Change the current working directory to the specified path\n        os.chdir(working_directory)\n        \n        # Ensure the folder path is a Path object for compatibility\n        folder_path = Path(folder_path)\n        \n        # Construct the full path for the zip file\n        zip_file_path = folder_path.parent / f\"{zip_name}.zip\"\n        \n        # Create a zip file and add all files from the specified folder\n        with zipfile.ZipFile(zip_file_path, 'w') as zipf:\n            for file in folder_path.glob('*'):\n                if file.is_file():\n                    zipf.write(file, arcname=file.name)\n        \n        print(f\"Task completed: '{zip_file_path}' has been created with all files from '{folder_path}'.\")\n\n# Example of how to use the class (this should be in comments):\n# To use this class, you would do something like the following:\n# zipper = zip_files()\n# zipper(folder_path='document', zip_name='agent', working_directory='/home/heroding/\u684c\u9762/Jarvis/working_dir')\n",
        "description": "Zip all the files in a specified folder and name the zip file with a specified filename."
    },
    "unzip_files": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport os\nimport zipfile\nimport subprocess\n\nclass unzip_files(BaseAction):\n    def __init__(self):\n        self._description = \"Unzip a specified .zip file into a designated folder.\"\n\n    def __call__(self, zip_file_path, destination_folder, working_directory=None, *args, **kwargs):\n        \"\"\"\n        Unzip the specified .zip file into the designated folder.\n\n        Args:\n            zip_file_path (str): The path to the .zip file to be unzipped.\n            destination_folder (str): The folder where the .zip file contents will be extracted.\n            working_directory (str, optional): The working directory where the operation will be performed.\n                If not provided, the current working directory will be used.\n\n        Returns:\n            None\n        \"\"\"\n        # If a working directory is provided, change to that directory\n        if working_directory:\n            os.chdir(working_directory)\n        else:\n            # Use the current working directory if none is provided\n            working_directory = os.getcwd()\n\n        # Ensure the destination folder exists\n        destination_path = os.path.join(working_directory, destination_folder)\n        os.makedirs(destination_path, exist_ok=True)\n\n        # Unzip the file\n        try:\n            with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:\n                zip_ref.extractall(destination_path)\n            print(f\"Unzipped {zip_file_path} into {destination_folder} successfully.\")\n        except zipfile.BadZipFile:\n            print(f\"Failed to unzip {zip_file_path}: The file may be corrupted or not a zip file.\")\n        except FileNotFoundError:\n            print(f\"Failed to unzip {zip_file_path}: The file does not exist.\")\n\n# Example of how to use the class (this should be in the comments and not executed):\n# unzipper = unzip_files()\n# unzipper(zip_file_path='agent.zip', destination_folder='myfold', working_directory='/home/heroding/\u684c\u9762/Jarvis/working_dir')\n",
        "description": "Unzip a specified .zip file into a designated folder."
    },
    "retrieve_document": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport os\n\nclass retrieve_document(BaseAction):\n    def __init__(self):\n        self._description = \"Search for .txt files containing a specific keyword within a designated folder and log their paths.\"\n\n    def __call__(self, keyword=\"agent\", folder_name=\"document\", working_dir=None, *args, **kwargs):\n        \"\"\"\n        Search for text files in the specified folder that contain the given keyword and log their full paths to a file.\n\n        Args:\n            keyword (str): The keyword to search for within text files. Defaults to \"agent\".\n            folder_name (str): The name of the folder to search within. Defaults to \"document\".\n            working_dir (str): The working directory where the folder is located. If not provided, uses the current working directory.\n\n        Returns:\n            None: This method does not return anything but writes the paths of matching files to 'agent.txt'.\n        \"\"\"\n        # Set the working directory to the provided path or the current working directory\n        if working_dir is None:\n            working_dir = os.getcwd()\n\n        # The path to the folder where the search will be performed\n        search_path = os.path.join(working_dir, folder_name)\n\n        # The file to which the paths of the matching text files will be written\n        output_file_path = os.path.join(working_dir, 'agent.txt')\n\n        # Check if the output file already exists and if so, rename it to avoid overwriting\n        if os.path.exists(output_file_path):\n            base, extension = os.path.splitext(output_file_path)\n            i = 1\n            new_output_file_path = f\"{base}_{i}{extension}\"\n            while os.path.exists(new_output_file_path):\n                i += 1\n                new_output_file_path = f\"{base}_{i}{extension}\"\n            output_file_path = new_output_file_path\n\n        # Initialize the output file\n        with open(output_file_path, 'w') as output_file:\n            # Walk through the directory\n            for root, dirs, files in os.walk(search_path):\n                for file in files:\n                    # Check if the file is a .txt file\n                    if file.endswith('.txt'):\n                        file_path = os.path.join(root, file)\n                        # Open and read the file to search for the keyword\n                        with open(file_path, 'r') as f:\n                            contents = f.read()\n                            # If the keyword is found, write the file's full path to the output file\n                            if keyword in contents:\n                                output_file.write(file_path + '\\n')\n\n        print(\"Task execution complete: Paths of text files containing the keyword have been logged to 'agent.txt'.\")\n\n# Example of how to use the class (this should be in comments):\n# retriever = retrieve_document()\n# retriever(keyword=\"agent\", folder_name=\"document\", working_dir=\"/home/heroding/\u684c\u9762/Jarvis/working_dir\")\n",
        "description": "Search for .txt files containing a specific keyword within a designated folder and log their paths."
    }
}