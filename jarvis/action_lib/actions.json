{
    "view_cpu_usage": {
        "code": "import os\nfrom jarvis.action.base_action import BaseAction\nimport subprocess\n\nclass view_cpu_usage(BaseAction):\n    def __init__(self):\n        self._description = \"Open the terminal interface and view the system's CPU usage.\"\n\n    def __call__(self, working_directory=None, *args, **kwargs):\n        \"\"\"\n        Open the terminal interface and view the system's CPU usage.\n\n        Args:\n        working_directory (str): The working directory where the terminal will be opened.\n        \n        Returns:\n        None\n        \"\"\"\n        # Check if working_directory is provided, if not, use the current working directory\n        if working_directory:\n            # Change the current working directory to the provided working_directory\n            os.chdir(working_directory)\n        \n        # Open the terminal and call relevant instructions to view the system's CPU usage\n        subprocess.run([\"gnome-terminal\", \"--\", \"top\"])\n",
        "description": "Open the terminal interface and view the system's CPU usage."
    },
    "create_folder": {
        "code": "from jarvis.action.base_action import BaseAction\nimport os\n\nclass create_folder(BaseAction):\n    def __init__(self):\n        self._description = \"Create a folder under the default working directory.\"\n\n    def __call__(self, working_directory=None, folder_name='myfold', *args, **kwargs):\n        \"\"\"\n        Create a folder under the specified working directory or the default working directory.\n\n        Args:\n        working_directory (str): The path of the working directory. If not provided, the default working directory will be used.\n        folder_name (str): The name of the folder to be created. Default is 'myfold'.\n\n        Returns:\n        None\n        \"\"\"\n        # Check if the working_directory is provided, if not, use the default working directory\n        if working_directory:\n            os.chdir(working_directory)\n\n        # Create the folder\n        os.makedirs(folder_name)\n\n# Example of how to use the class\n# create_folder_action = create_folder()\n# create_folder_action(working_directory='/home/heroding/\u684c\u9762/Jarvis/working_dir', folder_name='my_new_folder')\n",
        "description": "Create a folder under the default working directory."
    },
    "install_package": {
        "code": "from jarvis.action.base_action import BaseAction\nimport subprocess\nimport sys\n\n\nclass install_package(BaseAction):\n    def __init__(self) -> None:\n        super().__init__()\n        self._description = \"install environment missing package.\"\n        self.action_type = 'BASH'\n\n    def __call__(self, package: str, *args, **kwargs):\n\n        \"\"\"\n        Install a Python package using pip.\n\n        Args:\n        package_name (str): Name of the package to install.\n        \"\"\"\n        try:\n            subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])\n            print(f\"Package '{package}' installed successfully.\")\n        except subprocess.CalledProcessError as e:\n            print(f\"Failed to install package '{package}'. Error: {e}\")\n        \n        # try:\n        #     # \u68c0\u67e5pip\u662f\u5426\u5df2\u5b89\u88c5\n        #     print(\"check pip ...\")\n        #     subprocess.check_call([sys.executable, '-m', 'pip', '--version'])\n        # except subprocess.CalledProcessError:\n        #     # \u5b89\u88c5pip\n        #     print(\"Installing pip...\")\n        #     subprocess.check_call([sys.executable, '-m', 'ensurepip'])\n\n        # # \u5b89\u88c5\u6307\u5b9a\u7684\u5305\n        # try:\n        #     print(f\"Installing {package}...\")\n        #     subprocess.check_call([sys.executable, '-m', 'pip', 'install', package])\n        #     print(f\"{package} installed successfully.\")\n        # except subprocess.CalledProcessError:\n        #     print(f\"Failed to install {package}.\")        \n\n",
        "description": "install environment missing package."
    },
    "zip_files": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport os\nimport zipfile\nfrom pathlib import Path\n\nclass zip_files(BaseAction):\n    def __init__(self):\n        self._description = \"Zip all the files in a specified folder and name the zip file with a specified filename.\"\n\n    def __call__(self, folder_path, zip_name, working_directory=None):\n        \"\"\"\n        Create a zip archive of all files in the specified folder.\n\n        Args:\n            folder_path (str): The path to the folder whose files are to be zipped.\n            zip_name (str): The name of the resulting zip file.\n            working_directory (str, optional): The working directory where the folder is located. \n                If not provided, the current working directory is used.\n\n        Returns:\n            None: This method performs a task and does not return a value.\n        \"\"\"\n        # Use the provided working directory or the current working directory if not provided\n        working_directory = working_directory or os.getcwd()\n        \n        # Change the current working directory to the specified path\n        os.chdir(working_directory)\n        \n        # Ensure the folder path is a Path object for compatibility\n        folder_path = Path(folder_path)\n        \n        # Construct the full path for the zip file\n        zip_file_path = folder_path.parent / f\"{zip_name}.zip\"\n        \n        # Create a zip file and add all files from the specified folder\n        with zipfile.ZipFile(zip_file_path, 'w') as zipf:\n            for file in folder_path.glob('*'):\n                if file.is_file():\n                    zipf.write(file, arcname=file.name)\n        \n        print(f\"Task completed: '{zip_file_path}' has been created with all files from '{folder_path}'.\")\n\n# Example of how to use the class (this should be in comments):\n# To use this class, you would do something like the following:\n# zipper = zip_files()\n# zipper(folder_path='document', zip_name='agent', working_directory='/home/heroding/\u684c\u9762/Jarvis/working_dir')\n",
        "description": "Zip all the files in a specified folder and name the zip file with a specified filename."
    },
    "unzip_files": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport os\nimport zipfile\nimport subprocess\n\nclass unzip_files(BaseAction):\n    def __init__(self):\n        self._description = \"Unzip a specified .zip file into a designated folder.\"\n\n    def __call__(self, zip_file_path, destination_folder, working_directory=None, *args, **kwargs):\n        \"\"\"\n        Unzip the specified .zip file into the designated folder.\n\n        Args:\n            zip_file_path (str): The path to the .zip file to be unzipped.\n            destination_folder (str): The folder where the .zip file contents will be extracted.\n            working_directory (str, optional): The working directory where the operation will be performed.\n                If not provided, the current working directory will be used.\n\n        Returns:\n            None\n        \"\"\"\n        # If a working directory is provided, change to that directory\n        if working_directory:\n            os.chdir(working_directory)\n        else:\n            # Use the current working directory if none is provided\n            working_directory = os.getcwd()\n\n        # Ensure the destination folder exists\n        destination_path = os.path.join(working_directory, destination_folder)\n        os.makedirs(destination_path, exist_ok=True)\n\n        # Unzip the file\n        try:\n            with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:\n                zip_ref.extractall(destination_path)\n            print(f\"Unzipped {zip_file_path} into {destination_folder} successfully.\")\n        except zipfile.BadZipFile:\n            print(f\"Failed to unzip {zip_file_path}: The file may be corrupted or not a zip file.\")\n        except FileNotFoundError:\n            print(f\"Failed to unzip {zip_file_path}: The file does not exist.\")\n\n# Example of how to use the class (this should be in the comments and not executed):\n# unzipper = unzip_files()\n# unzipper(zip_file_path='agent.zip', destination_folder='myfold', working_directory='/home/heroding/\u684c\u9762/Jarvis/working_dir')\n",
        "description": "Unzip a specified .zip file into a designated folder."
    },
    "search_word": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport os\n\nclass search_word(BaseAction):\n    def __init__(self):\n        self._description = \"Search each text file for a specified word and return the paths of files that contain the word.\"\n\n    def __call__(self, file_paths, search_term, *args, **kwargs):\n        \"\"\"\n        Search each text file in the provided list for the specified word and return the paths of files that contain the word.\n\n        Args:\n            file_paths (list): List of absolute paths to text files to be searched.\n            search_term (str): The word to search for within the text files.\n\n        Returns:\n            list: The paths of files that contain the search term.\n        \"\"\"\n        matching_files = []\n        for file_path in file_paths:\n            try:\n                with open(file_path, 'r', encoding='utf-8') as file:\n                    if search_term in file.read():\n                        matching_files.append(file_path)\n            except FileNotFoundError:\n                print(f\"The file {file_path} does not exist.\")\n            except Exception as e:\n                print(f\"An error occurred while searching the file {file_path}: {e}\")\n\n        print(f\"Task execution complete. Found {len(matching_files)} files containing the word '{search_term}'.\")\n        return matching_files\n\n# Example of how to use the class (this should be in the comments):\n# searcher = search_word()\n# result = searcher(file_paths=['/path/to/file1.txt', '/path/to/file2.txt'], search_term='agent')\n",
        "description": "Search each text file for a specified word and return the paths of files that contain the word."
    },
    "read_layout_file": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport os\n\nclass read_layout_file(BaseAction):\n    def __init__(self):\n        self._description = \"Read the content of a specified text file.\"\n\n    def __call__(self, file_path, *args, **kwargs):\n        \"\"\"\n        Read the content of the specified text file and return its content.\n\n        Args:\n            file_path (str): The absolute path to the text file to be read.\n\n        Returns:\n            str: The content of the text file.\n        \"\"\"\n        try:\n            with open(file_path, 'r', encoding='utf-8') as file:\n                content = file.read()\n            print(f\"Task execution complete. Content of the file {file_path} read successfully.\")\n            return content\n        except FileNotFoundError:\n            print(f\"The file {file_path} does not exist.\")\n        except Exception as e:\n            print(f\"An error occurred while reading the file {file_path}: {e}\")\n\n# Example of how to use the class (this should be in the comments):\n# reader = read_layout_file()\n# content = reader(file_path='/home/heroding/.cache/huggingface/datasets/downloads/70a1ee0ae9b188db8f50a933dc95ce2e1cd3cbe2d015c7b4bd91444f003db5fd.txt')\n",
        "description": "Read the content of a specified text file."
    },
    "extract_excel_content": {
        "code": "from jarvis.action.base_action import BaseAction\nimport pandas as pd\nimport os\n\nclass extract_excel_content(BaseAction):\n    def __init__(self):\n        self._description = \"Extract the full text content of the specified Excel file.\"\n\n    def __call__(self, excel_file_path, *args, **kwargs):\n        \"\"\"\n        Extract the full text content of the specified Excel file and return its content.\n\n        Args:\n            excel_file_path (str): The absolute path to the Excel file to be read.\n\n        Returns:\n            dict: A dictionary where each key is the sheet name and each value is the content of that sheet as a DataFrame.\n        \"\"\"\n        try:\n            # Read the Excel file\n            with pd.ExcelFile(excel_file_path) as xls:\n                # Dictionary to store content of each sheet\n                sheets_content = {}\n                max_rows = 0\n                max_columns = 0\n                for sheet_name in xls.sheet_names:\n                    # Read each sheet into a DataFrame\n                    df = pd.read_excel(xls, sheet_name)\n                    sheets_content[sheet_name] = df\n                    max_rows = max(max_rows, df.shape[0])\n                    max_columns = max(max_columns, df.shape[1])\n            pd.set_option('display.max_rows', max_rows)\n            pd.set_option('display.max_columns', max_columns)\n            print(f\"Task execution complete. Content of the Excel file {excel_file_path} extracted successfully.\")\n            return sheets_content\n        except FileNotFoundError:\n            print(f\"The Excel file {excel_file_path} does not exist.\")\n        except Exception as e:\n            print(f\"An error occurred while reading the Excel file {excel_file_path}: {e}\")\n\n# Example of how to use the class (this should be in the comments):\n# extractor = extract_excel_content()\n# content = extractor(excel_file_path='/home/heroding/.cache/huggingface/datasets/downloads/9fbb70f8ea7240bdd24693c968fa879fd2e186fdedf2d1e709c59e096c865b25.xlsx')\n",
        "description": "Extract the full text content of the specified Excel file."
    },
    "extract_pdf_content": {
        "code": "from jarvis.action.base_action import BaseAction\nimport PyPDF2\nimport os\n\nclass extract_pdf_content(BaseAction):\n    def __init__(self):\n        self._description = \"Extract the text content from a specified PDF file.\"\n\n    def __call__(self, pdf_file_path, *args, **kwargs):\n        \"\"\"\n        Extract the text content from the specified PDF file and return its content.\n\n        Args:\n            pdf_file_path (str): The absolute path to the PDF file to be read.\n\n        Returns:\n            str: The text content of the PDF file.\n        \"\"\"\n        try:\n            # Ensure the PDF file exists\n            if not os.path.isfile(pdf_file_path):\n                print(f\"The PDF file {pdf_file_path} does not exist.\")\n                return\n            \n            # Open the PDF file\n            with open(pdf_file_path, 'rb') as file:\n                pdf_reader = PyPDF2.PdfReader(file)\n                text_content = ''\n                \n                # Iterate through each page and extract text\n                for page_num in range(len(pdf_reader.pages)):\n                    page = pdf_reader.pages[page_num]\n                    text_content += page.extract_text()\n            \n            print(f\"Task execution complete. Content of the PDF file {pdf_file_path} extracted successfully.\")\n            return text_content\n        except FileNotFoundError:\n            print(f\"The PDF file {pdf_file_path} does not exist.\")\n        except PyPDF2.errors.PdfReadError as e:\n            print(f\"An error occurred while reading the PDF file {pdf_file_path}: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n\n\n# Example of how to use the class (this should be in the comments):\n# extractor = extract_pdf_content()\n# content = extractor(pdf_file_path='/home/heroding/.cache/huggingface/datasets/downloads/9f3ace58caffc356d97dd86ada4e266d2054f59dad0950f287f9791ddcff64fa.pdf')\n",
        "description": "Extract the text content from a specified PDF file."
    },
    "extract_jsonl_content": {
        "code": "\nfrom jarvis.action.base_action import BaseAction\nimport json\nimport os\n\nclass extract_jsonl_content(BaseAction):\n    def __init__(self):\n        self._description = \"Extract the full text content of the specified JSON Lines file.\"\n\n    def __call__(self, jsonl_file_path, *args, **kwargs):\n        \"\"\"\n        Extract the full text content of the specified JSON Lines file and return its content.\n\n        Args:\n            jsonl_file_path (str): The absolute path to the JSON Lines file to be read.\n\n        Returns:\n            list: A list of dictionaries, each representing a line in the JSON Lines file.\n        \"\"\"\n        try:\n            # Change the current working directory to the specified path if provided\n            working_dir = kwargs.get('working_dir', os.getcwd())\n            os.chdir(working_dir)\n\n            # Ensure the JSON Lines file exists\n            if not os.path.isfile(jsonl_file_path):\n                print(f\"The JSON Lines file {jsonl_file_path} does not exist.\")\n                return\n\n            # Read the JSON Lines file\n            content = []\n            with open(jsonl_file_path, 'r', encoding='utf-8') as file:\n                for line in file:\n                    content.append(json.loads(line.strip()))\n\n            print(f\"Task execution complete. Content of the JSON Lines file {jsonl_file_path} extracted successfully.\")\n            return content\n        except FileNotFoundError:\n            print(f\"The JSON Lines file {jsonl_file_path} does not exist.\")\n        except json.JSONDecodeError as e:\n            print(f\"An error occurred while parsing the JSON Lines file {jsonl_file_path}: {e}\")\n        except Exception as e:\n            print(f\"An unexpected error occurred: {e}\")\n\n# Example of how to use the class (this should be in the comments):\n# extractor = extract_jsonl_content()\n# content = extractor(jsonl_file_path='/home/heroding/\u684c\u9762/Jarvis/working_dir/2023_validation_metadata.jsonl')\n",
        "description": "Extract the full text content of the specified JSON Lines file."
    },
    "read_csv_file": {
        "code": "from jarvis.action.base_action import BaseAction\nimport pandas as pd\nimport os\n\nclass read_csv_file(BaseAction):\n    def __init__(self):\n        self._description = \"Read the content of a CSV file to extract data.\"\n\n    def __call__(self, csv_file_path, *args, **kwargs):\n        \"\"\"\n        Read the content of the specified CSV file and return its content as a DataFrame.\n\n        Args:\n            csv_file_path (str): The absolute path to the CSV file to be read.\n\n        Returns:\n            DataFrame: The content of the CSV file as a pandas DataFrame.\n        \"\"\"\n        try:\n            # Change the current working directory to the directory of the CSV file\n            dir_path = os.path.dirname(csv_file_path)\n            os.chdir(dir_path)\n            \n            # Set the display options of Pandas to show all rows and columns\n            pd.set_option('display.max_rows', None)\n            pd.set_option('display.max_columns', None)\n\n            # Read the CSV file\n            data = pd.read_csv(os.path.basename(csv_file_path))\n            print(f\"Task execution complete. Content of the CSV file {csv_file_path} read successfully.\")\n            return data\n        except FileNotFoundError:\n            print(f\"The CSV file {csv_file_path} does not exist.\")\n        except Exception as e:\n            print(f\"An error occurred while reading the CSV file {csv_file_path}: {e}\")\n\n\n# Example of how to use the class (this should be in the comments):\n# reader = read_csv_file()\n# penguin_data = reader(csv_file_path='/home/heroding/.cache/huggingface/datasets/downloads/f78694ef938cb07a34ab1ca2ccf515e1433c479ca40632f122d332288dda688b.csv')",
        "description": "Read the content of a CSV file to extract data."
    }
}